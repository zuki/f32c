# f32cコア

ここがf32c CPUのコア（中枢）です。pipeline.vhdはプロセッサに真の速度を提供する最も複雑な部分です。

バスの動作はパイプラインに由来するため、f32cバスに接続するSOCを作成するには、その信号を理解することが重要です。

# バス信号

メモリアクセスは、シンプルな信号伝達とタイトなタイミングを持つ32ビット同期バスを使用して行われます。

通常、f32cはマルチポートRAMアービタを使用します。このアービタは、物理RAMへの信号バスと、ビデオやDMAなどのCPUとSOC用の複数のポートを備えています。

有効なデータは、単一のデータレディクロックサイクル中にワイヤ上に「現れます」。 レディ信号が"High"になったタイミングに合わせてデータをサンプリングする必要があります。

```
    dmem_addr_strobe: std_logic;
```

ストローブ信号はメモリ要求信号です。マスタはストローブをロジック1に設定し、レディ信号を受信するまでそれを保持する必要があります。

```
    dmem_data_ready: std_logic;
```

レディ信号は、CPUクロックの1サイクル中にロジック1になります。（読み取りを実行している場合は）、まさにその時点でインスタンスデータをバスから読み取ることができます。

レディ信号と有効なデータはバス上にいつまでも存在しません。

書き込みを実行している場合に、単一クロックサイクルにロジック1が現れるのは、書き込みが完了したことを示しています。

data_readyがロジック1になった後には、次のCPUクロックサイクルでaddress_strobeをロジック0に設定する必要があります。そうしないと、新しい書き込みが開始されます。

ストローブが常に1に保持されている場合は、readyが1である間、ストローブは無視されます。次のサイクルでreadyが0になると、新しい書き込みサイクルが開始されます。

```
    dmem_write: std_logic;
```

書き込み信号のロジック1は、書き込みサイクルになることを定義します。書き込み信号のロジック0は読み取りサイクルを表します。

```
    dmem_byte_sel: std_logic_vector(3 downto 0);
```

32ビットワードのどのバイトを書き込むかを選択します。 たとえば、"1000" はMSBを書き込み、"0001"はLSBを書き込みます。読み取りについてはわかりません:)。おそらくNOPになるでしょう。読み取りでは常に32ビット全体を読み取るからです。

```
    dmem_addr: std_logic_vector(31 downto 2);
```

メモリアドレスです。f32cは32ビットアラインのメモリ転送しか行わないので、2 LSBアドレスビットは外部バスには現れません。

```
    dmem_data_in: std_logic_vector(31 downto 0);
    dmem_data_out: std_logic_vector(31 downto 0);
```

32ビットデータの入力と出力は別々にルーティングされ、f32cはトライステートバス転送を行いません。

# 非決定論的なケース

バスマスタで唯一サポートされている動作は、"adddress_strobe"を1に設定した時点からの動作です。"data_ready"が1になるまでは、何かを変更したり、転送を放棄することはできません。

読み取りサイクル中（"data_ready"が1になる前）にバスの状態が変更された場合、バスの内容は、他のポートのアクティビティに応じたランダムな数のクロック後にサンプリングされます。

書き込みサイクル中（"data_ready"が1になる前）にバスの状態が変更された場合、"data_ready"が1になるサイクルの直前のクロックサイクルでバスの内容がサンプリングされます。

# キャッシュ

命令キャッシュとデータキャッシュは個別に存在します。f32cブートローダーが機能するには、データキャッシュと命令キャッシュの間で、キャッシュが一貫している必要があります。

また、キャッシュは、現在は簡潔になるように実装されているため、命令フェッチサイクルは次のフェッチのためにアドレスを変更する前に完了（レディ信号を受信）する必要があります。

読み取りサイクルでキャッシュミスがあった場合、キャッシュは低速のRAMからデータのフェッチを開始します。読み取りサイクルが完了する前にアドレスが変更された場合は、キャッシュはRAMから古いデータを取り出し、新しい（間違った）アドレスに格納します。これはデータを破損させるもとになります。

したがって、アドレスストローブがキャッシュにアサートされたら、レディ信号を受信するまでアドレスを変更しないでください。

# キャッシュコヒーレンス

自己修正コードには、キャッシュの一貫性が必要です。

ブートローダーは、シリアルポート経由で新しいコンパイル済みコードを受け取った際、新しい（自己修正された）コードにジャンプする前に、命令キャッシュのデータ有効ビットへの0の書き込みを開始する別のCPUシグナルラインを使用するアセンブラのキャッシュ命令を使用して、命令キャッシュをフラッシュしようとします。 その後、新しいコードへのジャンプが機能できるようになります。

たとえば、自動的な一貫性を保証するベンダー固有のモジュールを使用して、命令キャッシュとデータキャッシュを異なる方法で実装することができます。その場合、このフラッシュ命令は切断されたキャッシュフラッシュ信号線を持つNOPになります。
